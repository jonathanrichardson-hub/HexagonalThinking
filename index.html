<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hexagonal Thinking</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f4f8;
            margin: 0;
            overflow: hidden;
        }

        /* Control Panel Styles */
        #controls {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            display: flex;
            gap: 15px;
            align-items: flex-start;
            flex-wrap: wrap;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            position: relative;
            z-index: 2000;
        }

        #wordList {
            height: 40px;
            width: 250px;
            border-radius: 4px;
            padding: 5px;
            font-family: inherit;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            height: 40px;
            align-self: flex-end;
        }

        button:hover { background-color: #2980b9; }
        .btn-share { background-color: #27ae60; }
        .btn-share:hover { background-color: #2ecc71; }
        .btn-mode { background-color: #8e44ad; }
        .btn-mode:hover { background-color: #9b59b6; }

        #board {
            width: 100vw;
            height: calc(100vh - 90px);
            position: relative;
        }

        /* Hexagon Styles */
        .hexagon {
            width: 120px;
            height: 138px;
            background-color: #34495e;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 15px;
            box-sizing: border-box;
            position: absolute;
            cursor: grab;
            user-select: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: background-color 0.2s;
            font-size: 14px;
            word-wrap: break-word;
        }

        .hexagon:active { cursor: grabbing; }
        .hexagon.has-notes { background-color: #e67e22; }

        /* Modal Styles */
        #noteModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            z-index: 3000;
            width: 400px;
        }

        #noteModal h3 { margin-top: 0; color: #2c3e50; }
        #noteText { width: 100%; height: 150px; margin-bottom: 10px; font-family: inherit; padding: 5px; box-sizing: border-box;}
        #modalOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2999;
        }
    </style>
</head>
<body>

    <div id="controls">
        <div>
            <label style="display:block; font-size:12px; margin-bottom:5px;">Paste words (comma separated or new lines):</label>
            <textarea id="wordList" placeholder="Democracy, Freedom..."></textarea>
        </div>
        <button onclick="spawnHexagons()">Spawn</button>
        <button id="dragModeBtn" class="btn-mode" onclick="toggleDragMode()">Mode: Move Groups</button>
        <button class="btn-share" onclick="generateShareLink()">Copy Share Link</button>
    </div>

    <div id="board"></div>

    <div id="modalOverlay" onclick="closeModal()"></div>
    <div id="noteModal">
        <h3 id="modalTitle">Connections</h3>
        <p style="font-size: 12px; color: #666;">Explain how this connects to its neighbors:</p>
        <textarea id="noteText"></textarea>
        <br>
        <button onclick="saveNote()">Save & Close</button>
    </div>

    <script>
        let hexagonsData = [];
        let activeHexId = null;
        let currentEditingId = null;
        let dragMode = 'group'; // 'group' or 'single'

        const board = document.getElementById('board');
        const dragModeBtn = document.getElementById('dragModeBtn');

        // Toggle Drag Mode
        function toggleDragMode() {
            if (dragMode === 'group') {
                dragMode = 'single';
                dragModeBtn.innerText = "Mode: Move Singles (Detaching)";
                dragModeBtn.style.backgroundColor = "#e74c3c"; // Turns red to indicate detachment mode
            } else {
                dragMode = 'group';
                dragModeBtn.innerText = "Mode: Move Groups";
                dragModeBtn.style.backgroundColor = "#8e44ad"; // Back to purple
            }
        }

        // 1. Spawning Randomly
        function spawnHexagons() {
            const text = document.getElementById('wordList').value;
            const words = text.split(/[\n,]+/).map(w => w.trim()).filter(w => w.length > 0);
            
            // Calculate safe boundaries so they don't spawn off-screen
            const maxX = Math.max(50, window.innerWidth - 150);
            const maxY = Math.max(50, window.innerHeight - 250);

            words.forEach((word, index) => {
                hexagonsData.push({
                    id: Date.now() + index,
                    word: word,
                    x: Math.floor(Math.random() * (maxX - 50 + 1)) + 50, // Random X position
                    y: Math.floor(Math.random() * (maxY - 50 + 1)) + 50, // Random Y position
                    notes: ""
                });
            });
            
            document.getElementById('wordList').value = ""; 
            renderBoard();
        }

        // 2. Rendering
        function renderBoard() {
            board.innerHTML = '';
            hexagonsData.forEach(hex => {
                const el = document.createElement('div');
                el.className = 'hexagon' + (hex.notes ? ' has-notes' : '');
                el.innerText = hex.word;
                el.style.left = hex.x + 'px';
                el.style.top = hex.y + 'px';
                el.dataset.id = hex.id;

                el.addEventListener('pointerdown', handlePointerDown);
                el.addEventListener('dblclick', () => openModal(hex.id));

                board.appendChild(el);
            });
        }

        // 3. Dragging Logic (Checks which mode is active)
        let startX, startY;
        let clusterIds = [];

        function handlePointerDown(e) {
            activeHexId = parseInt(e.target.dataset.id);
            startX = e.clientX;
            startY = e.clientY;
            
            // If in group mode, find neighbors. If in single mode, just move the one clicked.
            if (dragMode === 'group') {
                clusterIds = getConnectedCluster(activeHexId);
            } else {
                clusterIds = [activeHexId];
            }

            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
        }

        function handlePointerMove(e) {
            if (!activeHexId) return;
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            
            clusterIds.forEach(id => {
                const hex = hexagonsData.find(h => h.id === id);
                hex.x += dx;
                hex.y += dy;
                
                const el = document.querySelector(`.hexagon[data-id='${id}']`);
                if(el) {
                    el.style.left = hex.x + 'px';
                    el.style.top = hex.y + 'px';
                    el.style.zIndex = 1000;
                }
            });

            startX = e.clientX;
            startY = e.clientY;
        }

        function handlePointerUp() {
            clusterIds.forEach(id => {
                const el = document.querySelector(`.hexagon[data-id='${id}']`);
                if(el) el.style.zIndex = 1;
            });
            activeHexId = null;
            clusterIds = [];
            document.removeEventListener('pointermove', handlePointerMove);
            document.removeEventListener('pointerup', handlePointerUp);
        }

        // Math for clustering
        function getConnectedCluster(startId) {
            let cluster = new Set();
            let queue = [startId];
            
            while(queue.length > 0) {
                let curr = queue.shift();
                if(!cluster.has(curr)) {
                    cluster.add(curr);
                    const currHex = hexagonsData.find(h => h.id === curr);
                    
                    hexagonsData.forEach(h => {
                        if(h.id !== curr && !cluster.has(h.id)) {
                            const dist = Math.sqrt(Math.pow(currHex.x - h.x, 2) + Math.pow(currHex.y - h.y, 2));
                            if(dist < 140) queue.push(h.id);
                        }
                    });
                }
            }
            return Array.from(cluster);
        }

        // 4. Modals
        function openModal(id) {
            currentEditingId = id;
            const hex = hexagonsData.find(h => h.id === id);
            document.getElementById('modalTitle').innerText = "Connecting: " + hex.word;
            document.getElementById('noteText').value = hex.notes || "";
            document.getElementById('noteModal').style.display = 'block';
            document.getElementById('modalOverlay').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('noteModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            currentEditingId = null;
        }

        function saveNote() {
            const hex = hexagonsData.find(h => h.id === currentEditingId);
            hex.notes = document.getElementById('noteText').value;
            closeModal();
            renderBoard();
        }

        // 5. Save & Share
        function generateShareLink() {
            if (hexagonsData.length === 0) {
                alert("The board is empty!");
                return;
            }
            const dataString = JSON.stringify(hexagonsData);
            const encodedData = btoa(encodeURIComponent(dataString));
            const shareUrl = window.location.origin + window.location.pathname + "#" + encodedData;
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                alert("Success! The share link has been copied to your clipboard.");
            });
        }

        // 6. Load Shared Link
        window.onload = () => {
            if (window.location.hash) {
                try {
                    const encodedData = window.location.hash.substring(1);
                    const dataString = decodeURIComponent(atob(encodedData));
                    hexagonsData = JSON.parse(dataString);
                    renderBoard();
                } catch(e) {
                    console.error("Could not load shared board.", e);
                    alert("This share link seems to be broken or invalid.");
                }
            }
        }
    </script>
</body>
</html>
