<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Hexagonal Thinking</title>
    <style>
        /* Modern, Earthy Theme */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #FDFBF7; /* Warm alabaster */
            margin: 0;
            overflow: hidden;
            color: #4A3F35; /* Deep warm brown for readability */
        }

        /* Control Panel Styles */
        #controls {
            background-color: #4A3F35; /* Dark earthy brown */
            color: #FDFBF7;
            padding: 15px 20px;
            display: flex;
            gap: 15px;
            align-items: flex-start;
            flex-wrap: wrap;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            position: relative;
            z-index: 2000;
        }

        #wordList {
            height: 40px;
            width: 250px;
            border-radius: 6px;
            border: 1px solid #D4C5B9;
            padding: 5px 10px;
            font-family: inherit;
            background-color: #FFF;
            color: #4A3F35;
        }

        /* Modern, Soft Buttons */
        button {
            background-color: #C18C5D; /* Warm Ochre/Caramel */
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            height: 40px;
            align-self: flex-end;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button:hover { background-color: #A87A4F; transform: translateY(-1px); }
        
        .btn-share { background-color: #7A8B76; } /* Muted Sage */
        .btn-share:hover { background-color: #647360; }
        
        .btn-mode { background-color: #6C809A; } /* Muted Slate */
        .btn-mode:hover { background-color: #56687F; }
        
        .btn-danger { background-color: #B05C52; } /* Muted Terracotta/Brick */
        .btn-danger:hover { background-color: #944B43; }

        #board {
            width: 100vw;
            height: calc(100vh - 90px);
            position: relative;
        }

        /* Hexagon Styles */
        .hexagon {
            width: 120px;
            height: 138px;
            background-color: #BA8E7A; /* Warm Clay */
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 15px;
            box-sizing: border-box;
            position: absolute;
            cursor: grab;
            user-select: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            transition: background-color 0.3s ease, transform 0.1s;
            font-size: 14px;
            word-wrap: break-word;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }

        .hexagon:active { cursor: grabbing; transform: scale(1.02); }
        .hexagon.has-notes { background-color: #829377; } /* Sage Green when notes exist */

        /* Modal Styles */
        #noteModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #FDFBF7;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            z-index: 3000;
            width: 400px;
            border: 1px solid #E5DCD3;
        }

        #noteModal h3 { margin-top: 0; color: #4A3F35; font-weight: 600; }
        #noteText { 
            width: 100%; 
            height: 150px; 
            margin-bottom: 15px; 
            font-family: inherit; 
            padding: 10px; 
            box-sizing: border-box;
            border: 1px solid #D4C5B9;
            border-radius: 6px;
            background-color: #FFF;
            color: #4A3F35;
        }
        
        #modalOverlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(74, 63, 53, 0.4); /* Warm transparent overlay */
            backdrop-filter: blur(2px);
            z-index: 2999;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>
<body>

    <div id="controls">
        <div>
            <label style="display:block; font-size:12px; margin-bottom:5px; color: #E5DCD3;">Paste words (comma separated or new lines):</label>
            <textarea id="wordList" placeholder="Democracy, Freedom..."></textarea>
        </div>
        <button onclick="spawnHexagons()">Spawn</button>
        <button id="dragModeBtn" class="btn-mode" onclick="toggleDragMode()">Mode: Move Groups</button>
        <button class="btn-share" onclick="generateShareLink()">Copy Share Link</button>
        <button class="btn-danger" onclick="clearBoard()">Clear Board</button>
    </div>

    <div id="board"></div>

    <div id="modalOverlay" onclick="closeModal()"></div>
    <div id="noteModal">
        <h3 id="modalTitle">Connections</h3>
        <p style="font-size: 13px; color: #7A6B5D;">Explain how this connects to its neighbors:</p>
        <textarea id="noteText"></textarea>
        <div class="modal-buttons">
            <button onclick="saveNote()">Save & Close</button>
            <button class="btn-danger" onclick="deleteHexagon()">Delete Hexagon</button>
        </div>
    </div>

    <script>
        let hexagonsData = [];
        let activeHexId = null;
        let currentEditingId = null;
        let dragMode = 'group'; 

        const board = document.getElementById('board');
        const dragModeBtn = document.getElementById('dragModeBtn');

        // Toggle Drag Mode
        function toggleDragMode() {
            if (dragMode === 'group') {
                dragMode = 'single';
                dragModeBtn.innerText = "Mode: Move Singles (Detaching)";
                dragModeBtn.style.backgroundColor = "#B05C52"; // Terracotta warning
            } else {
                dragMode = 'group';
                dragModeBtn.innerText = "Mode: Move Groups";
                dragModeBtn.style.backgroundColor = "#6C809A"; // Back to Slate
            }
        }

        // 1. Spawning
        function spawnHexagons() {
            const text = document.getElementById('wordList').value;
            const words = text.split(/[\n,]+/).map(w => w.trim()).filter(w => w.length > 0);
            
            const maxX = Math.max(50, window.innerWidth - 150);
            const maxY = Math.max(50, window.innerHeight - 250);

            words.forEach((word, index) => {
                hexagonsData.push({
                    id: Date.now() + index,
                    word: word,
                    x: Math.floor(Math.random() * (maxX - 50 + 1)) + 50,
                    y: Math.floor(Math.random() * (maxY - 50 + 1)) + 50,
                    notes: ""
                });
            });
            
            document.getElementById('wordList').value = ""; 
            renderBoard();
        }

        // 2. Rendering
        function renderBoard() {
            board.innerHTML = '';
            hexagonsData.forEach(hex => {
                const el = document.createElement('div');
                el.className = 'hexagon' + (hex.notes ? ' has-notes' : '');
                el.innerText = hex.word;
                el.style.left = hex.x + 'px';
                el.style.top = hex.y + 'px';
                el.dataset.id = hex.id;

                el.addEventListener('pointerdown', handlePointerDown);
                el.addEventListener('dblclick', () => openModal(hex.id));

                board.appendChild(el);
            });
        }

        // 3. Dragging Logic
        let startX, startY;
        let clusterIds = [];

        function handlePointerDown(e) {
            activeHexId = parseInt(e.target.dataset.id);
            startX = e.clientX;
            startY = e.clientY;
            
            if (dragMode === 'group') {
                clusterIds = getConnectedCluster(activeHexId);
            } else {
                clusterIds = [activeHexId];
            }

            document.addEventListener('pointermove', handlePointerMove);
            document.addEventListener('pointerup', handlePointerUp);
        }

        function handlePointerMove(e) {
            if (!activeHexId) return;
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            
            clusterIds.forEach(id => {
                const hex = hexagonsData.find(h => h.id === id);
                hex.x += dx;
                hex.y += dy;
                
                const el = document.querySelector(`.hexagon[data-id='${id}']`);
                if(el) {
                    el.style.left = hex.x + 'px';
                    el.style.top = hex.y + 'px';
                    el.style.zIndex = 1000;
                }
            });

            startX = e.clientX;
            startY = e.clientY;
        }

        function handlePointerUp() {
            clusterIds.forEach(id => {
                const el = document.querySelector(`.hexagon[data-id='${id}']`);
                if(el) el.style.zIndex = 1;
            });
            activeHexId = null;
            clusterIds = [];
            document.removeEventListener('pointermove', handlePointerMove);
            document.removeEventListener('pointerup', handlePointerUp);
        }

        function getConnectedCluster(startId) {
            let cluster = new Set();
            let queue = [startId];
            
            while(queue.length > 0) {
                let curr = queue.shift();
                if(!cluster.has(curr)) {
                    cluster.add(curr);
                    const currHex = hexagonsData.find(h => h.id === curr);
                    
                    hexagonsData.forEach(h => {
                        if(h.id !== curr && !cluster.has(h.id)) {
                            const dist = Math.sqrt(Math.pow(currHex.x - h.x, 2) + Math.pow(currHex.y - h.y, 2));
                            if(dist < 140) queue.push(h.id);
                        }
                    });
                }
            }
            return Array.from(cluster);
        }

        // 4. Modals and Deleting
        function openModal(id) {
            currentEditingId = id;
            const hex = hexagonsData.find(h => h.id === id);
            document.getElementById('modalTitle').innerText = "Connecting: " + hex.word;
            document.getElementById('noteText').value = hex.notes || "";
            document.getElementById('noteModal').style.display = 'block';
            document.getElementById('modalOverlay').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('noteModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            currentEditingId = null;
        }

        function saveNote() {
            const hex = hexagonsData.find(h => h.id === currentEditingId);
            hex.notes = document.getElementById('noteText').value;
            closeModal();
            renderBoard();
        }

        // NEW: Delete a single hexagon
        function deleteHexagon() {
            if (confirm("Are you sure you want to delete this hexagon?")) {
                // Filter out the one we are currently editing
                hexagonsData = hexagonsData.filter(h => h.id !== currentEditingId);
                closeModal();
                renderBoard();
            }
        }

        // NEW: Clear the entire board
        function clearBoard() {
            if (confirm("Are you sure you want to clear the entire board? This cannot be undone.")) {
                hexagonsData = []; // Empties the array
                renderBoard(); // Redraws the blank board
            }
        }

        // 5. Save & Share
        function generateShareLink() {
            if (hexagonsData.length === 0) {
                alert("The board is empty!");
                return;
            }
            const dataString = JSON.stringify(hexagonsData);
            const encodedData = btoa(encodeURIComponent(dataString));
            const shareUrl = window.location.origin + window.location.pathname + "#" + encodedData;
            
            navigator.clipboard.writeText(shareUrl).then(() => {
                alert("Success! The share link has been copied to your clipboard.");
            });
        }

        // 6. Load Shared Link
        window.onload = () => {
            if (window.location.hash) {
                try {
                    const encodedData = window.location.hash.substring(1);
                    const dataString = decodeURIComponent(atob(encodedData));
                    hexagonsData = JSON.parse(dataString);
                    renderBoard();
                } catch(e) {
                    console.error("Could not load shared board.", e);
                    alert("This share link seems to be broken or invalid.");
                }
            }
        }
    </script>
</body>
</html>
